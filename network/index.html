<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器相关 | 橘子</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="icon" href="/blog/favicon.ico">
    <link rel="manifest" href="/blog/manifest.json">
    <link rel="mask-icon" href="/blog/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="明日可期">
    <meta name="author" content="bright">
    <meta name="keywords" content="前端 随记 笔记 webpack gulp grunt 自动化构建 脚手架 Yeoman plop ES6 promise vue 浏览器缓存 函数式编程 虚拟DOM">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/blog/assets/css/0.styles.8a31d08e.css" as="style"><link rel="preload" href="/blog/assets/js/app.806523c4.js" as="script"><link rel="preload" href="/blog/assets/js/2.bfb3ed95.js" as="script"><link rel="preload" href="/blog/assets/js/14.03b9db9c.js" as="script"><link rel="preload" href="/blog/assets/js/3.38b041cb.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.e22ab2a4.js"><link rel="prefetch" href="/blog/assets/js/11.9b6afde3.js"><link rel="prefetch" href="/blog/assets/js/12.1881e8b2.js"><link rel="prefetch" href="/blog/assets/js/13.591e9158.js"><link rel="prefetch" href="/blog/assets/js/15.8acf6f69.js"><link rel="prefetch" href="/blog/assets/js/16.887430fe.js"><link rel="prefetch" href="/blog/assets/js/17.018b2b77.js"><link rel="prefetch" href="/blog/assets/js/18.dcc85b92.js"><link rel="prefetch" href="/blog/assets/js/19.c9b2a5b0.js"><link rel="prefetch" href="/blog/assets/js/20.3349f2c8.js"><link rel="prefetch" href="/blog/assets/js/21.2430deee.js"><link rel="prefetch" href="/blog/assets/js/22.5cb0bf92.js"><link rel="prefetch" href="/blog/assets/js/23.bff58062.js"><link rel="prefetch" href="/blog/assets/js/24.d64e1905.js"><link rel="prefetch" href="/blog/assets/js/25.6e7a99f7.js"><link rel="prefetch" href="/blog/assets/js/26.6251e442.js"><link rel="prefetch" href="/blog/assets/js/27.795d7e54.js"><link rel="prefetch" href="/blog/assets/js/28.68c69371.js"><link rel="prefetch" href="/blog/assets/js/4.a5e4891f.js"><link rel="prefetch" href="/blog/assets/js/5.7165873c.js"><link rel="prefetch" href="/blog/assets/js/6.f680b873.js"><link rel="prefetch" href="/blog/assets/js/7.17ca32f2.js"><link rel="prefetch" href="/blog/assets/js/8.7acd39b4.js"><link rel="prefetch" href="/blog/assets/js/9.f5c94ac4.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8a31d08e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">橘子</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/network/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  浏览器
</a></div><div class="nav-item"><a href="/blog/note/ES6.html" class="nav-link">
  随记
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frame/Vue/base.html" class="nav-link">
  Vue
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/network/" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  浏览器
</a></div><div class="nav-item"><a href="/blog/note/ES6.html" class="nav-link">
  随记
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frame/Vue/base.html" class="nav-link">
  Vue
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>network</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/network/JSONP.html" class="sidebar-link">JSONP原理及实现</a></li><li><a href="/blog/network/Promise.html" class="sidebar-link">Promise</a></li><li><a href="/blog/network/PromiseTopic.html" class="sidebar-link">Promise由浅入深题目-加深理解</a></li><li><a href="/blog/network/" aria-current="page" class="active sidebar-link">浏览器相关</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/#_1-关于浏览器缓存" class="sidebar-link">1.关于浏览器缓存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/#_1-1-强缓存" class="sidebar-link">1.1 强缓存</a></li><li class="sidebar-sub-header"><a href="/blog/network/#_1-2-协商缓存" class="sidebar-link">1.2 协商缓存</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/network/#_2-浏览器本地存储" class="sidebar-link">2.浏览器本地存储</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/network/#cookie" class="sidebar-link">Cookie</a></li><li class="sidebar-sub-header"><a href="/blog/network/#localstorage" class="sidebar-link">localStorage</a></li><li class="sidebar-sub-header"><a href="/blog/network/#sessionstorage" class="sidebar-link">sessionStorage</a></li><li class="sidebar-sub-header"><a href="/blog/network/#indexeddb" class="sidebar-link">IndexedDB</a></li></ul></li></ul></li><li><a href="/blog/network/URL.html" class="sidebar-link">输入URL到页面的呈现</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="_1-关于浏览器缓存"><a href="#_1-关于浏览器缓存" class="header-anchor">#</a> 1.关于浏览器缓存</h2> <p>缓存是性能优化中非常重要的一个环节。浏览器中缓存分为：</p> <ul><li>强缓存</li> <li>协商缓存</li></ul> <h3 id="_1-1-强缓存"><a href="#_1-1-强缓存" class="header-anchor">#</a> 1.1 强缓存</h3> <p>浏览器中的缓存分为两种情况，一种是需要发送<code>http</code>请求，一种是不需要发送
首先检查强缓存，这个阶段不需要发送请求<br>
但是要怎么检查呢？通过字段来检查，<code>http/1.0</code>和<code>http/1.1</code>,检查的字段是不太一样的，在<code>http/1.0</code>时期，检查的是<code>Expires</code>，<code>http/1.1</code>中检查的是<code>Cache-Control</code></p> <h4 id="expires"><a href="#expires" class="header-anchor">#</a> Expires</h4> <p><code>expires</code>表示过期时间，存在于服务器返回的响应头中，告诉浏览器在这个时间过期之前可以直接从缓存中获取数据，不需要发送请求，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>Expires<span class="token operator">:</span> Wed<span class="token punctuation">,</span> <span class="token number">22</span> Oct <span class="token number">2018</span> <span class="token number">08</span><span class="token operator">:</span><span class="token number">41</span><span class="token operator">:</span><span class="token number">00</span> <span class="token constant">GMT</span>
</code></pre></div><p>表示资源在<code>2019年11月22号8点41分</code>过期，过期了就得向服务端发请求</p> <p>这其中存在一个问题，就是客户端的时间和服务端的时间可能存在差异，那么这个时间就是不准确的，所以在<code>http/1.1</code>中，这种方式就被抛弃了</p> <h4 id="cache-control"><a href="#cache-control" class="header-anchor">#</a> Cache-Control</h4> <p><code>http/1.1</code>中采用这个<code>Cache-Control</code>这个字段，也是存在于服务器返回的响应头中，不过它并没有具体的过期时间，而是采用的过期时长来控制缓存有效时间，对应字段是<code>max-age</code>,例如：</p> <div class="language-js extra-class"><pre class="language-js"><code>Cache<span class="token operator">-</span>Control<span class="token operator">:</span>max<span class="token operator">-</span>age<span class="token operator">=</span><span class="token number">3600</span>
</code></pre></div><p>这个意思代表着在3600秒，也就是一个小时内可以直接使用缓存中的数据而不用发送请求<br>
它还有其他的属性</p> <ul><li><code>public</code>：客户端和服务端都可以缓存。一个请求可能会经过很多个代理服务器，才会到达目标服务器，这种情况下，中间的代理服务器也可以缓存</li> <li><code>private</code>: 只有浏览器可以缓存，中间的代理服务器不能缓存</li> <li><code>no-cache</code>：跳过当前缓存，发送<code>http</code>请求，直接进入协商缓存阶段</li> <li><code>no-store</code>：不进行任何的缓存</li> <li><code>s-maxage</code>：同<code>max-age</code>作用一样，只在代理服务器中生效，它的优先级会高于<code>max-age</code>，如果存在<code>s-maxage</code>，则会覆盖掉<code>max-age</code>和<code>Expires</code></li></ul> <p>当<code>Expires</code>和<code>Cache-Control</code>同时存在的时候，会优先考虑<code>Cache-Control</code><br>
当资源缓存超时了，也就是<code>强缓存</code>失效了，接下来就会进入到<strong>协商缓存</strong></p> <h3 id="_1-2-协商缓存"><a href="#_1-2-协商缓存" class="header-anchor">#</a> 1.2 协商缓存</h3> <p>强缓存失效后，浏览器在请求头中携带相应的<code>tag</code>来向服务器发送请求，由服务器根据这个<code>tag</code>来决定是否使用缓存，这个就是<strong>协商缓存</strong><br>
缓存的<code>tag</code>分为两种，一种是<code>Last-Modified</code>和<code>Etag</code></p> <h4 id="last-modified"><a href="#last-modified" class="header-anchor">#</a> Last-Modified</h4> <p>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段<br>
浏览器接收到后，如果再次请求，会带上<code>If-Modified-Since</code>字段，值也就是服务器传来的最后修改时间<br>
服务器拿到请求头中的<code>If-Modified-Since</code>字段后，会和服务器中<code>该资源的最后修改时间</code>作对比：</p> <ul><li>如果请求头中的时间小于最后修改时间，说明更新了，返回新的资源，跟常规的<code>HTTP</code>一样</li> <li>否则返回<code>304</code>，告诉浏览器直接使用缓存</li></ul> <h4 id="etag"><a href="#etag" class="header-anchor">#</a> ETag</h4> <p><code>ETag</code>是服务器根据当前文件的内容，给文件生成的唯一标识，只要文件改动，这个值就会发生变化，服务器通过<code>响应头</code>把这个值传递个浏览器<br>
浏览器拿到这个<code>ETag</code>的值之后，会在下次请求中带上<code>If-None-Match</code>字段，值就是接收的<code>ETag</code>的值，发给服务器<br>
服务器接收到<code>If-None-Match</code>字段，和服务器上资源的<code>ETag</code>进行比较，</p> <ul><li>如果不一样，说明资源更新了，返回新的资源</li> <li>否则返回304，告诉浏览器直接使用缓存</li></ul> <h4 id="last-modified和etag比较"><a href="#last-modified和etag比较" class="header-anchor">#</a> Last-Modified和ETag比较</h4> <ol><li>精准度上，<code>ETag</code>优于<code>Last-Modified</code>，优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
<ul><li>编辑了资源文件，但是内容并没有修改，会造成缓存失效</li> <li><code>Last-Modified</code>能够感知的时间是秒，如果在<code>1s</code>内改变了很多次，这个时候它就不能体现出具体的修改</li></ul></li> <li>性能上，<code>Last-Modified</code>优于<code>ETag</code>，因为<code>Last-Modified</code>只是记录一个时间，而<code>ETag</code>需要根据文件内容生成哈希值
如果两种方式都支持的话，服务器会优先考虑<code>ETag</code></li></ol> <h2 id="_2-浏览器本地存储"><a href="#_2-浏览器本地存储" class="header-anchor">#</a> 2.浏览器本地存储</h2> <p>浏览器本地存储主要有：</p> <ul><li><code>Cookie</code></li> <li><code>WebStorage</code> <ul><li><code>sessionStorage</code></li> <li><code>localStorage</code></li></ul></li> <li><code>IndexedDB</code></li></ul> <h3 id="cookie"><a href="#cookie" class="header-anchor">#</a> Cookie</h3> <p><code>Cookie</code>是在浏览器里面存储一个很小的文本文件，内部以键值对的方式存储，向同一域名下发送请求，都会携带相同的<code>Cookie</code>，服务器拿到<code>Cookie</code>进行解析，便可以拿到客户端的状态，它就是用来做<strong>状态存储</strong>的，但是它有一些缺陷</p> <ul><li>容量缺陷，只能存储<code>4kb</code>大小的信息</li> <li>性能缺陷，同域名下的所有请求都会自动带上完整的<code>Cookie</code>信息，即使这个请求不需要，如果请求数量很多很多的话，就会造成一定的性能浪费</li> <li>安全缺陷，<code>Cookie</code>在浏览器和服务器之间的的传输形式是纯文本的，容易被非法用户截获，然后篡改，然后在<code>Cookie</code>有效期内在发送给服务器，这样是非常危险的，还有在<code>HttpOnly</code>为<code>false</code>的情况下，<code>Cookie</code>中的信息是可以通过<code>JS</code>脚本进行读取的。</li></ul> <h3 id="localstorage"><a href="#localstorage" class="header-anchor">#</a> localStorage</h3> <p><code>localStorage</code>和<code>Cookie</code>类似，针对同一域名，在同一域名下，存储相同的一段<code>localStorage</code></p> <p>不过它相对于<code>Cookie</code>来说，有一定的区别</p> <ul><li>容量上，<code>localStorage</code>的存储容量上限为<code>5M</code></li> <li>时间上，对于同一域名，如果不手动删除，理论上是一直存在的，也就是说是<strong>持久存储</strong>的</li> <li>因为不需要和服务端进行通信，所以没有了<code>Cookie</code>带来的<strong>安全问题</strong>和<strong>性能问题</strong></li> <li>操作非常方便，它本身带有<code>setItem</code>和<code>getItem</code>等方法，我们只需要调用这些方法对其进行操作</li></ul> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token operator">:</span> <span class="token string">'星光'</span><span class="token punctuation">,</span> age<span class="token operator">:</span> <span class="token number">18</span><span class="token punctuation">}</span>
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">'people'</span><span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>people<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>接下在同域名下获取和移除也是非常简单的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 获取</span>
<span class="token keyword">const</span> peopleStr <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'people'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> peopleFromLocal <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>peopleStr<span class="token punctuation">)</span> <span class="token comment">// {name: &quot;星光&quot;, age: 18}</span>
<span class="token comment">// 移除</span>
localStorage<span class="token punctuation">.</span><span class="token function">removeItem</span><span class="token punctuation">(</span><span class="token string">'people'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> peopleInfo <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">'people'</span><span class="token punctuation">)</span> <span class="token comment">// null</span>
</code></pre></div><p>可以看到，它只能存储字符串，通过<code>JSON.stringify()</code>方法把对象转出字符串，通过<code>JSON.parse()</code>解析成对象</p> <h3 id="sessionstorage"><a href="#sessionstorage" class="header-anchor">#</a> sessionStorage</h3> <p><code>sessionStorage</code>和<code>localStorage</code>基本一样，</p> <ul><li>容量上限为<code>5M</code></li> <li>只存在于客户端，不与服务端进行通信</li> <li>操作方式与<code>localStorage</code>一致</li></ul> <p>但是<code>sessionStorage</code>和<code>localStorage</code>有个本质的区别，就是<code>sessionStorage</code>是会话级别的存储，不是持久性存储，当会话结束，也就是页面被关闭之后，存储在<code>sessionStorage</code>中的信息就不在了</p> <h3 id="indexeddb"><a href="#indexeddb" class="header-anchor">#</a> IndexedDB</h3> <p><code>IndexedDB</code>是运行在浏览器端的<code>非关系型数据库</code>，存储容量理论上是没有上限的<br>
有一些需要注意的点</p> <ul><li>采用<code>键值对</code>进行存储</li> <li>受浏览器同源策略</li> <li>异步操作，数据库的读写属于I/O，浏览器中对异步I/O提供了支持, 异步设计是为了防止大量数据的读写，拖慢网页的表现。</li></ul> <p>总结一下：</p> <ul><li><code>Cookie</code>并不适合存储</li> <li><code>localStorage</code>和<code>sessionStorage</code>不会与服务端通信</li> <li><code>IndexedDB</code>是运行在浏览器端的数据库，为大型数据的存储提供了接口</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2020年5月19日星期二下午2点17分</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/network/PromiseTopic.html" class="prev">
        Promise由浅入深题目-加深理解
      </a></span> <span class="next"><a href="/blog/network/URL.html">
        输入URL到页面的呈现
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/blog/assets/js/app.806523c4.js" defer></script><script src="/blog/assets/js/2.bfb3ed95.js" defer></script><script src="/blog/assets/js/14.03b9db9c.js" defer></script><script src="/blog/assets/js/3.38b041cb.js" defer></script>
  </body>
</html>
