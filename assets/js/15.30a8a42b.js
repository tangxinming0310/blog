(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{348:function(_,v,t){"use strict";t.r(v);var a=t(21),e=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("p",[_._v("首先，在地址栏中输入了网址")]),_._v(" "),t("div",{staticClass:"language-html extra-class"},[t("pre",{pre:!0,attrs:{class:"language-html"}},[t("code",[_._v("https://www.baidu.com\n")])])]),t("p",[_._v("然后中间需要经历哪些过程之后，页面才会呈现在我们眼前呢？")]),_._v(" "),t("h1",{attrs:{id:"网络请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络请求"}},[_._v("#")]),_._v(" 网络请求")]),_._v(" "),t("h3",{attrs:{id:"_1-构建请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-构建请求"}},[_._v("#")]),_._v(" 1.构建请求")]),_._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 请求的方法是 GET, 路径是根路径，HTTP协议版本是1.1")]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("GET")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("HTTP")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("1.1")]),_._v("\n")])])]),t("h3",{attrs:{id:"_2-查找强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-查找强缓存"}},[_._v("#")]),_._v(" 2.查找强缓存")]),_._v(" "),t("p",[_._v("先检查强缓存，如果命中则直接使用缓存，否则进入下一步")]),_._v(" "),t("h3",{attrs:{id:"_3-dns解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-dns解析"}},[_._v("#")]),_._v(" 3.DNS解析")]),_._v(" "),t("p",[_._v("因为我们输入的是域名，而数据是通过"),t("code",[_._v("IP地址")]),_._v("进行传输，所以我们需要得到域名对应的"),t("code",[_._v("IP")]),_._v("，这个过程需要依赖一个系统，这个系统将域名和"),t("code",[_._v("IP")]),_._v("一一进行映射，我们把这个系统叫做"),t("strong",[_._v("DNS")]),_._v("（域名系统），得到具体的"),t("code",[_._v("IP")]),_._v("的过程就叫做"),t("strong",[_._v("DNS解析")]),t("br"),_._v("\n当然，浏览器提供了"),t("strong",[_._v("DNS数据缓存功能")]),_._v("，即一个域名已经解析过，那么就会把解析的结果存下来，下次访问的时候直接走缓存，不需要再次进行"),t("code",[_._v("DNS解析")]),t("br"),_._v("\n如果不指名端口号的话，默认采用对应的 IP 的 80 端口")]),_._v(" "),t("h3",{attrs:{id:"_4-建立tcp连接"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-建立tcp连接"}},[_._v("#")]),_._v(" 4.建立TCP连接")]),_._v(" "),t("p",[t("code",[_._v("Chrome")]),_._v("在同一个域名下，同时最多只能有"),t("code",[_._v("6")]),_._v("个"),t("code",[_._v("TCP")]),_._v("连接，超过"),t("code",[_._v("6")]),_._v("个，剩下的连接就需要等待")]),_._v(" "),t("blockquote",[t("p",[_._v("TCP(Transmission Control Protocol, 传输控制协议)是一种面向连接的，可靠的，基于字节流的传输层通信协议")])]),_._v(" "),t("p",[_._v("构建"),t("code",[_._v("TCP")]),_._v("连接需要经过以下几个阶段：")]),_._v(" "),t("ul",[t("li",[_._v("通过"),t("strong",[_._v("三次握手")]),_._v("建立客户端和服务器之间的连接")]),_._v(" "),t("li",[_._v("进行数据传输。数据传输中有一个比较重要的机制，就是接受方接收到数据包之后需要向发送方"),t("code",[_._v("确认")]),_._v("，如果发送方没有收到这个"),t("code",[_._v("确认")]),_._v("消息就会判定数据包丢失，并且重新发送该数据包，同时，发送过程中有一个优化策略，就是"),t("code",[_._v("大的数据包拆分成一个个的小包")]),_._v("，依次传输到接收方，接收方按照小包的顺序把它们"),t("code",[_._v("组装")]),_._v("完整的数据包")]),_._v(" "),t("li",[_._v("断开连接的阶段，当数据传输完成之后，就要断开连接，通过"),t("code",[_._v("四次挥手")]),_._v("来断开连接")])]),_._v(" "),t("p",[t("code",[_._v("TCP")]),_._v("连接一是通过"),t("code",[_._v("三次握手")]),_._v("确认连接，二是通过"),t("code",[_._v("数据包校验")]),_._v("保证数据的传输，三是通过"),t("code",[_._v("四次挥手")]),_._v("断开连接")]),_._v(" "),t("p",[_._v("关于"),t("code",[_._v("三次握手")]),_._v("与"),t("code",[_._v("四次挥手")]),_._v("更详细的解答可以看 "),t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/86426969",target:"_blank",rel:"noopener noreferrer"}},[_._v("解答"),t("OutboundLink")],1)]),_._v(" "),t("h3",{attrs:{id:"_5-发送http请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-发送http请求"}},[_._v("#")]),_._v(" 5.发送http请求")]),_._v(" "),t("p",[_._v("现在"),t("code",[_._v("tcp")]),_._v("连接已经建立完毕，浏览器和服务器可以进行通信，就开始发送"),t("code",[_._v("http")]),_._v("请求，浏览器"),t("code",[_._v("http")]),_._v("请求由"),t("strong",[_._v("请求行")]),_._v("、"),t("strong",[_._v("请求头")]),_._v("，"),t("strong",[_._v("空行")]),_._v("和"),t("strong",[_._v("请求体")]),_._v("组成\n请求行很简单，由"),t("strong",[_._v("请求方式")]),_._v("，"),t("strong",[_._v("请求路径")]),_._v("和"),t("strong",[_._v("HTTP版本协议")]),_._v("组成")]),_._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[_._v("// 请求的方法是 GET, 路径是根路径，HTTP协议版本是1.1")]),_._v("\n"),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("GET")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("HTTP")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("1.1")]),_._v("\n")])])]),t("p",[_._v("请求头包括了"),t("code",[_._v("Cookie")]),_._v(","),t("code",[_._v("Cache-Control")]),_._v(","),t("code",[_._v("If-Modified-Since")]),_._v(","),t("code",[_._v("If-None-Match")]),_._v(","),t("code",[_._v("User-Agent")]),_._v("等信息")]),_._v(" "),t("p",[_._v("请求体只有在"),t("code",[_._v("POST")]),_._v("方法下存在，常见的场景是表单提交")]),_._v(" "),t("h1",{attrs:{id:"网络响应"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#网络响应"}},[_._v("#")]),_._v(" 网络响应")]),_._v(" "),t("p",[t("code",[_._v("HTTP")]),_._v("请求到达服务器，服务器进行相应的处理。最后要把数据传给浏览器，也就是返回网络响应"),t("br"),_._v("\n和请求部分类似，响应部分包括了"),t("strong",[_._v("响应行")]),_._v("，"),t("strong",[_._v("响应头")]),_._v("和"),t("strong",[_._v("响应体")]),t("br"),_._v("\n响应行由"),t("code",[_._v("HTTP协议版本")]),_._v("、"),t("code",[_._v("状态码")]),_._v("、"),t("code",[_._v("状态描述")]),_._v("组成")]),_._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("HTTP")]),t("span",{pre:!0,attrs:{class:"token operator"}},[_._v("/")]),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("1.1")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[_._v("200")]),_._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[_._v("OK")]),_._v("\n")])])]),t("p",[_._v("响应头包含了服务器返回的数据信息,比如说生成数据的时间，数据类型和Cookie等信息")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("Cache-Control: no-cache\nConnection: keep-alive\nContent-Encoding: gzip\nContent-Type: text/html;charset=utf-8\nDate: Wed, 04 Dec 2019 12:29:13 GMT\nServer: apache\nSet-Cookie: rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com\n\n")])])]),t("p",[_._v("响应完成之后，需要判断"),t("code",[_._v("Connection")]),_._v("字段，如果请求头或者响应头中包含了"),t("code",[_._v("Connection:Keep-Alive")]),_._v("，那么表示建立了持久连接，这样"),t("code",[_._v("TCP")]),_._v("连接会一直保持，之后请求统一站点的资源会复用这个连接，否则就断开连接，这个时候"),t("strong",[_._v("请求-响应")]),_._v("的流程就结束了")]),_._v(" "),t("h1",{attrs:{id:"资源解析，布局渲染"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源解析，布局渲染"}},[_._v("#")]),_._v(" 资源解析，布局渲染")]),_._v(" "),t("p",[_._v("对于获取到的"),t("code",[_._v("HTML")]),_._v(", "),t("code",[_._v("CSS")]),_._v(", "),t("code",[_._v("JS")]),_._v("等资源，主要步骤是：")]),_._v(" "),t("ul",[t("li",[_._v("解析"),t("code",[_._v("HTML")]),_._v("，生成"),t("code",[_._v("DOM树")])]),_._v(" "),t("li",[_._v("解析"),t("code",[_._v("CSS")]),_._v("生成"),t("code",[_._v("CSS规则树")])]),_._v(" "),t("li",[_._v("通过"),t("code",[_._v("DOM树")]),_._v("和"),t("code",[_._v("CSS规则树")]),_._v("生成渲染树，渲染树中没有"),t("code",[_._v("display:none")]),_._v("的元素")]),_._v(" "),t("li",[_._v("进行样式计算布局")]),_._v(" "),t("li",[_._v("遍历渲染树，绘制页面")])]),_._v(" "),t("p",[_._v("在浏览器还没完全接收到完整的"),t("code",[_._v("HTML")]),_._v("文件时，它就已经开始渲染页面了，在遇见外部链入的脚本标签或者样式标签或图片时，会再次发送"),t("code",[_._v("HTTP")]),_._v("请求重复上述步骤，在收到"),t("code",[_._v("CSS")]),_._v("文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完会立即显示在正确的位置，这个过程中可能会触发页面的重绘和重排")]),_._v(" "),t("h1",{attrs:{id:"重绘与重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘与重排"}},[_._v("#")]),_._v(" 重绘与重排")]),_._v(" "),t("img",{staticClass:"custom",attrs:{src:_.$withBase("/Parsing.png"),alt:"Parsing"}}),_._v(" "),t("h2",{attrs:{id:"回流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流"}},[_._v("#")]),_._v(" 回流")]),_._v(" "),t("p",[_._v("先说一下"),t("code",[_._v("回流")]),_._v("，"),t("code",[_._v("回流")]),_._v("也叫"),t("code",[_._v("重排")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"触发条件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发条件"}},[_._v("#")]),_._v(" 触发条件")]),_._v(" "),t("p",[_._v("当我们对"),t("code",[_._v("DOM")]),_._v("的修改引发了"),t("code",[_._v("DOM")]),_._v("几何尺寸变化的时候，会发生"),t("code",[_._v("回流")]),_._v("过程\n比如说，一下操作就会触发回流：")]),_._v(" "),t("ol",[t("li",[_._v("一个DOM元素的几何属性发生变化，常见的几何属性有 "),t("code",[_._v("width")]),_._v(", "),t("code",[_._v("height")]),_._v(", "),t("code",[_._v("padding")]),_._v(", "),t("code",[_._v("margin")]),_._v(", "),t("code",[_._v("left")]),_._v(", "),t("code",[_._v("top")]),_._v(", "),t("code",[_._v("border")]),_._v("等")]),_._v(" "),t("li",[_._v("使DOM节点发生"),t("code",[_._v("增减")]),_._v("或者"),t("code",[_._v("移动")])]),_._v(" "),t("li",[_._v("读写"),t("code",[_._v("offset")]),_._v("族, "),t("code",[_._v("scroll")]),_._v("族, "),t("code",[_._v("client")]),_._v("族属性的时候，浏览器为了获取这些值，需要进行回流操作")]),_._v(" "),t("li",[_._v("调用"),t("code",[_._v("window.getComputedStyle")]),_._v("方法")])]),_._v(" "),t("h3",{attrs:{id:"回流过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回流过程"}},[_._v("#")]),_._v(" 回流过程")]),_._v(" "),t("p",[_._v("按照上面的流水线，触发回流的时候，如果DOM结构发生改变，则重新渲染DOM树，然后后面的流程（包括了主线程之外的任务）全部走一遍。相当于将解析和合成的过程又走了一遍，开销是非常大的。")]),_._v(" "),t("img",{staticClass:"custom",attrs:{src:_.$withBase("/reflow.png"),alt:"reflow"}}),_._v(" "),t("h2",{attrs:{id:"重绘"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[_._v("#")]),_._v(" 重绘")]),_._v(" "),t("h3",{attrs:{id:"触发条件-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#触发条件-2"}},[_._v("#")]),_._v(" 触发条件")]),_._v(" "),t("p",[_._v("当DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致"),t("code",[_._v("重绘")])]),_._v(" "),t("h3",{attrs:{id:"重绘过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘过程"}},[_._v("#")]),_._v(" 重绘过程")]),_._v(" "),t("p",[_._v("由于没有导致DOM几何属性的更新，因此元素的位置信息不需要更新，从而省去布局的过程，流程")]),_._v(" "),t("img",{staticClass:"custom",attrs:{src:_.$withBase("/repaint.png"),alt:"repaint"}}),_._v(" "),t("p",[_._v("跳过了"),t("code",[_._v("生成布局树")]),_._v("和"),t("code",[_._v("建图层树")]),_._v("的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作")]),_._v(" "),t("p",[_._v("可以看到，重绘不一定导致回流，但是回流一定发生了重绘。")]),_._v(" "),t("h2",{attrs:{id:"合成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#合成"}},[_._v("#")]),_._v(" 合成")]),_._v(" "),t("p",[_._v("还有一种情况是直接合成，比如利用CSS3的"),t("code",[_._v("transform")]),_._v("，"),t("code",[_._v("opacity")]),_._v("，"),t("code",[_._v("filter")]),_._v("这些属性是可以实现合成的效果，也就是常说的"),t("strong",[_._v("GPU加速")])]),_._v(" "),t("h3",{attrs:{id:"gpu加速的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gpu加速的原因"}},[_._v("#")]),_._v(" GPU加速的原因")]),_._v(" "),t("p",[_._v("在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给"),t("code",[_._v("合成线程")]),_._v("处理。\n交给它处理有两大好处:")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。")])]),_._v(" "),t("li",[t("p",[_._v("没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。")])])]),_._v(" "),t("h2",{attrs:{id:"实践意义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实践意义"}},[_._v("#")]),_._v(" 实践意义")]),_._v(" "),t("p",[_._v("知道原理后，对开发过程的指导意义")]),_._v(" "),t("ol",[t("li",[_._v("避免频繁的使用"),t("code",[_._v("style")]),_._v("，而是采用"),t("code",[_._v("class")]),_._v("的方式")]),_._v(" "),t("li",[_._v("使用"),t("code",[_._v("createDocumentFragment")]),_._v("进行批量的DOM操作")]),_._v(" "),t("li",[_._v("对于"),t("code",[_._v("resize")]),_._v(","),t("code",[_._v("scroll")]),_._v("等进行防抖/节流的处理")]),_._v(" "),t("li",[_._v("添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。有一个实际的例子，一行will-change: tranform拯救一个项目，"),t("a",{attrs:{href:"https://juejin.im/post/5da52531518825094e373372",target:"_blank",rel:"noopener noreferrer"}},[_._v("查看详情"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=e.exports}}]);