---
title: 浏览器相关
---
## 1.关于浏览器缓存
缓存是性能优化中非常重要的一个环节。浏览器中缓存分为：
  + 强缓存
  + 协商缓存

### 1.1 强缓存
浏览器中的缓存分为两种情况，一种是需要发送`http`请求，一种是不需要发送
首先检查强缓存，这个阶段不需要发送请求  
但是要怎么检查呢？通过字段来检查，`http/1.0`和`http/1.1`,检查的字段是不太一样的，在`http/1.0`时期，检查的是`Expires`，`http/1.1`中检查的是`Cache-Control`

#### Expires
`expires`表示过期时间，存在于服务器返回的响应头中，告诉浏览器在这个时间过期之前可以直接从缓存中获取数据，不需要发送请求，比如：
```js
Expires: Wed, 22 Oct 2018 08:41:00 GMT
```
表示资源在`2019年11月22号8点41分`过期，过期了就得向服务端发请求

这其中存在一个问题，就是客户端的时间和服务端的时间可能存在差异，那么这个时间就是不准确的，所以在`http/1.1`中，这种方式就被抛弃了

#### Cache-Control

`http/1.1`中采用这个`Cache-Control`这个字段，也是存在于服务器返回的响应头中，不过它并没有具体的过期时间，而是采用的过期时长来控制缓存有效时间，对应字段是`max-age`,例如：
```js
Cache-Control:max-age=3600
```
这个意思代表着在3600秒，也就是一个小时内可以直接使用缓存中的数据而不用发送请求  
它还有其他的属性  
  + `public`：客户端和服务端都可以缓存。一个请求可能会经过很多个代理服务器，才会到达目标服务器，这种情况下，中间的代理服务器也可以缓存
  + `private`: 只有浏览器可以缓存，中间的代理服务器不能缓存
  + `no-cache`：跳过当前缓存，发送`http`请求，直接进入协商缓存阶段
  + `no-store`：不进行任何的缓存
  + `s-maxage`：同`max-age`作用一样，只在代理服务器中生效，它的优先级会高于`max-age`，如果存在`s-maxage`，则会覆盖掉`max-age`和`Expires`

当`Expires`和`Cache-Control`同时存在的时候，会优先考虑`Cache-Control`  
当资源缓存超时了，也就是`强缓存`失效了，接下来就会进入到**协商缓存**
### 协商缓存
强缓存失效后，浏览器在请求头中携带相应的`tag`来向服务器发送请求，由服务器根据这个`tag`来决定是否使用缓存，这个就是**协商缓存**  
缓存的`tag`分为两种，一种是`Last-Modified`和`Etag`

#### Last-Modified
即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段  
浏览器接收到后，如果再次请求，会带上`If-Modified-Since`字段，值也就是服务器传来的最后修改时间  
服务器拿到请求头中的`If-Modified-Since`字段后，会和服务器中`该资源的最后修改时间`作对比：
  + 如果请求头中的时间小于最后修改时间，说明更新了，返回新的资源，跟常规的`HTTP`一样
  + 否则返回`304`，告诉浏览器直接使用缓存

#### ETag
`ETag`是服务器根据当前文件的内容，给文件生成的唯一标识，只要文件改动，这个值就会发生变化，服务器通过`响应头`把这个值传递个浏览器  
浏览器拿到这个`ETag`的值之后，会在下次请求中带上`If-None-Match`字段，值就是接收的`ETag`的值，发给服务器  
服务器接收到`If-None-Match`字段，和服务器上资源的`ETag`进行比较，
  + 如果不一样，说明资源更新了，返回新的资源
  + 否则返回304，告诉浏览器直接使用缓存

#### Last-Modified和ETag比较
  1. 精准度上，`ETag`优于`Last-Modified`，优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
      + 编辑了资源文件，但是内容并没有修改，会造成缓存失效
      + `Last-Modified`能够感知的时间是秒，如果在`1s`内改变了很多次，这个时候它就不能体现出具体的修改
  2. 性能上，`Last-Modified`优于`ETag`，因为`Last-Modified`只是记录一个时间，而`ETag`需要根据文件内容生成哈希值
如果两种方式都支持的话，服务器会优先考虑`ETag`