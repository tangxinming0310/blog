---
title: 输入URL到页面的呈现
---
首先，在地址栏中输入了网址
```html
https://www.baidu.com
```
然后中间需要经历哪些过程之后，页面才会呈现在我们眼前呢？
# 网络请求
### 1.构建请求
```js
// 请求的方法是 GET, 路径是根路径，HTTP协议版本是1.1
GET / HTTP/1.1
```
### 2.查找强缓存
先检查强缓存，如果命中则直接使用缓存，否则进入下一步

### 3.DNS解析
因为我们输入的是域名，而数据是通过`IP地址`进行传输，所以我们需要得到域名对应的`IP`，这个过程需要依赖一个系统，这个系统将域名和`IP`一一进行映射，我们把这个系统叫做**DNS**（域名系统），得到具体的`IP`的过程就叫做**DNS解析**  
当然，浏览器提供了**DNS数据缓存功能**，即一个域名已经解析过，那么就会把解析的结果存下来，下次访问的时候直接走缓存，不需要再次进行`DNS解析`  
如果不指名端口号的话，默认采用对应的 IP 的 80 端口

### 4.建立TCP连接
`Chrome`在同一个域名下，同时最多只能有`6`个`TCP`连接，超过`6`个，剩下的连接就需要等待
> TCP(Transmission Control Protocol, 传输控制协议)是一种面向连接的，可靠的，基于字节流的传输层通信协议

构建`TCP`连接需要经过以下几个阶段：
  + 通过**三次握手**建立客户端和服务器之间的连接
  + 进行数据传输。数据传输中有一个比较重要的机制，就是接受方接收到数据包之后需要向发送方`确认`，如果发送方没有收到这个`确认`消息就会判定数据包丢失，并且重新发送该数据包，同时，发送过程中有一个优化策略，就是`大的数据包拆分成一个个的小包`，依次传输到接收方，接收方按照小包的顺序把它们`组装`完整的数据包
  + 断开连接的阶段，当数据传输完成之后，就要断开连接，通过`四次挥手`来断开连接

`TCP`连接一是通过`三次握手`确认连接，二是通过`数据包校验`保证数据的传输，三是通过`四次挥手`断开连接

关于`三次握手`与`四次挥手`更详细的解答可以看 [解答](https://zhuanlan.zhihu.com/p/86426969)

### 5.发送http请求
现在`tcp`连接已经建立完毕，浏览器和服务器可以进行通信，就开始发送`http`请求，浏览器`http`请求由**请求行**、**请求头**，**空行**和**请求体**组成
请求行很简单，由**请求方式**，**请求路径**和**HTTP版本协议**组成
```js
// 请求的方法是 GET, 路径是根路径，HTTP协议版本是1.1
GET / HTTP/1.1
```
请求头包括了`Cookie`,`Cache-Control`,`If-Modified-Since`,`If-None-Match`,`User-Agent`等信息

请求体只有在`POST`方法下存在，常见的场景是表单提交

# 网络响应
`HTTP`请求到达服务器，服务器进行相应的处理。最后要把数据传给浏览器，也就是返回网络响应  
和请求部分类似，响应部分包括了**响应行**，**响应头**和**响应体**  
响应行由`HTTP协议版本`、`状态码`、`状态描述`组成

```js
HTTP/1.1 200 OK
```  
响应头包含了服务器返回的数据信息,比如说生成数据的时间，数据类型和Cookie等信息
```
Cache-Control: no-cache
Connection: keep-alive
Content-Encoding: gzip
Content-Type: text/html;charset=utf-8
Date: Wed, 04 Dec 2019 12:29:13 GMT
Server: apache
Set-Cookie: rsv_i=f9a0SIItKqzv7kqgAAgphbGyRts3RwTg%2FLyU3Y5Eh5LwyfOOrAsvdezbay0QqkDqFZ0DfQXby4wXKT8Au8O7ZT9UuMsBq2k; path=/; domain=.baidu.com

```

响应完成之后，需要判断`Connection`字段，如果请求头或者响应头中包含了`Connection:Keep-Alive`，那么表示建立了持久连接，这样`TCP`连接会一直保持，之后请求统一站点的资源会复用这个连接，否则就断开连接，这个时候**请求-响应**的流程就结束了

# 资源解析，布局渲染
对于获取到的`HTML`, `CSS`, `JS`等资源，主要步骤是：  
  + 解析`HTML`，生成`DOM树`
  + 解析`CSS`生成`CSS规则树`
  + 通过`DOM树`和`CSS规则树`生成渲染树，渲染树中没有`display:none`的元素
  + 进行样式计算布局
  + 遍历渲染树，绘制页面

在浏览器还没完全接收到完整的`HTML`文件时，它就已经开始渲染页面了，在遇见外部链入的脚本标签或者样式标签或图片时，会再次发送`HTTP`请求重复上述步骤，在收到`CSS`文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完会立即显示在正确的位置，这个过程中可能会触发页面的重绘和重排  

# 重绘与重排

<img class="custom" :src="$withBase('/Parsing.png')" alt="Parsing">  

## 回流
先说一下`回流`，`回流`也叫`重排`。

### 触发条件
当我们对`DOM`的修改引发了`DOM`几何尺寸变化的时候，会发生`回流`过程
比如说，一下操作就会触发回流：
  1. 一个DOM元素的几何属性发生变化，常见的几何属性有 `width`, `height`, `padding`, `margin`, `left`, `top`, `border`等
  2. 使DOM节点发生`增减`或者`移动`
  3. 读写`offset`族, `scroll`族, `client`族属性的时候，浏览器为了获取这些值，需要进行回流操作
  4. 调用`window.getComputedStyle`方法

### 回流过程
按照上面的流水线，触发回流的时候，如果DOM结构发生改变，则重新渲染DOM树，然后后面的流程（包括了主线程之外的任务）全部走一遍。相当于将解析和合成的过程又走了一遍，开销是非常大的。

<img class="custom" :src="$withBase('/reflow.png')" alt="reflow"> 

## 重绘
### 触发条件
当DOM 的修改导致了样式的变化，并且没有影响几何属性的时候，会导致`重绘`

### 重绘过程
由于没有导致DOM几何属性的更新，因此元素的位置信息不需要更新，从而省去布局的过程，流程

<img class="custom" :src="$withBase('/repaint.png')" alt="repaint"> 

跳过了`生成布局树`和`建图层树`的阶段，直接生成绘制列表，然后继续进行分块、生成位图等后面一系列操作  

可以看到，重绘不一定导致回流，但是回流一定发生了重绘。

## 合成
还有一种情况是直接合成，比如利用CSS3的`transform`，`opacity`，`filter`这些属性是可以实现合成的效果，也就是常说的**GPU加速**

### GPU加速的原因
在合成的情况下，会直接跳过布局和绘制流程，直接进入非主线程处理的部分，即直接交给`合成线程`处理。
交给它处理有两大好处:

  1. 能够充分发挥GPU的优势。合成线程生成位图的过程中会调用线程池，并在其中使用GPU进行加速生成，而GPU 是擅长处理位图数据的。

  2. 没有占用主线程的资源，即使主线程卡住了，效果依然能够流畅地展示。

## 实践意义
知道原理后，对开发过程的指导意义
  1. 避免频繁的使用`style`，而是采用`class`的方式
  2. 使用`createDocumentFragment`进行批量的DOM操作
  3. 对于`resize`,`scroll`等进行防抖/节流的处理
  4. 添加 will-change: tranform ，让渲染引擎为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。当然这个变化不限于tranform, 任何可以实现合成效果的 CSS 属性都能用will-change来声明。有一个实际的例子，一行will-change: tranform拯救一个项目，[查看详情](https://juejin.im/post/5da52531518825094e373372)